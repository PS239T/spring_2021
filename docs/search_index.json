[
["index.html", "Computational Thinking for Social Scientists Chapter 1 PS239T", " Computational Thinking for Social Scientists Jae Yeon Kim 2020-09-26 Chapter 1 PS239T Welcome to PS239T This course will help social science graduate students to think computationally and develop proficiency with computational tools and techniques, necessary to conduct research in computational social science. Mastering these tools and techniques not only enables students to collect, wrangle, analyze, and interpret data with less pain and more fun, but it also let students to work on research projects that would previously seem impossible. The course is currently divided into two main subjects (fundamentals and applications) and six main sessions. Part I Fundamentals In the first section, students learn best practices in data and code management using Git and Bash. In the second, students learn how to wrangle, model, and visualize data easier and faster. In the third, students learn how to use functions to automate repeated things and develop their own data tools (e.g., packages). Part II Applications In the fourth, students learn how to collect and parse semi-structured data at scale (e.g., using APIs and webscraping). In the fifth, students learn how to analyze high-dimensional data (e.g., text) using machine learning. In the final, students learn how to access, query, and manage big data using SQL. Instructor and course developer Jae Yeon Kim: jaeyeonkim@berkeley.edu History This course is a remix version of the course originally developed by Rochelle Terman. Questions, comments, or suggestions Please create issues, if you have questions, comments, or suggestions. This work is licensed under a Creative Commons Attribution 4.0 International License. "],
["Intro.html", "Chapter 2 Managing data and code 2.1 Project-oriented research 2.2 Writing code: How to code like a professional 2.3 Asking questions: Minimal reproducible example", " Chapter 2 Managing data and code 2.1 Project-oriented research 2.1.1 Computational reproducibility 2.1.1.1 Setup pacman::p_load( tidyverse, # tidyverse here # computational reproducibility ) 2.1.1.2 Motivation Why do you need to make your research project computationally reproducible? For your self-interest and public benefits. 2.1.1.3 How to organize files in a project You cannot reproduce your project if it is not efficiently organized. Step 1. Environment is part of your project. Don’t share them across workspaces. If someone can’t reproduce your environment, they won’t be able to run your code. Launch R Studio. Choose Tools &gt; Global Options. You should not check Restor .RData into workspace at startup and set saving workspace option to NEVER. Step 2. For each project, create a project directory named after the project. # Don&#39;t name it a project. Use a name that&#39;s more informative. dir.create(&quot;../starwars&quot;) Step 3. Launch R Studio. Choose File &gt; New project &gt; Browse existing directories &gt; Create project This allows each project has its own workspace. Step 4. Organize files by putting them in separate subdirectories and naming them in a sensible way. Treat raw data as read only (raw data should be RAW!) and put in the data directory. dir.create(here::here(&quot;project&quot;, &quot;data&quot;)) Separate read-only data from processed data and put in the processed_data subdirectory. dir.create(here::here(&quot;project&quot;, &quot;processed_data&quot;)) Put your code in the src directory. dir.create(here::here(&quot;project&quot;, &quot;processed_data&quot;)) Put generated outputs (e.g., tables, figures) in the outputs subdirectory and treat them as disposable. dir.create(here::here(&quot;project&quot;, &quot;outputs&quot;)) Put your custom functions in the functions subdirectory. You can put some of them together later as a package. dir.create(here::here(&quot;project&quot;, &quot;functions&quot;)) Challenge 1 Set a project structure for a project named “starwars”. 2.1.1.4 How to organize code in a R markdown file In addition to environment, workflow is an important component of project efficiency and reproducibility. R Markdown basic syntax # Header 1 ## Header 2 ### Header 3 Use these section headings to indicate workflow. # Import packages and data # Tidy data # Wrangle data # Model data # Visualize data Press ctrl + shift + o. You can see a document outline based on these headings. This is a nice feature for finding code you need to focus. If your project’s scale is large, then divide these sections into files, number, and save them in code subdirectory. 01_tidying.Rmd 02_transforming.Rmd … 2.1.1.5 Making a project computationally reproducible setwd(): set a working directory. Note that using setwd() is not a reproducible way to set up your project. For instance, none will be able to run the following code except me. # Set a working directory setwd(&quot;/home/jae/starwars&quot;) # Do something ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point() # dot means the working directory set by setwd() ggsave(&quot;./outputs/example.png&quot;) # This is called relative path Instead, learn how to use here()’. Key idea: separate workflow (e.g., workspace information) from products (code and data). For more information, read Jenny Bryan’s wonderful piece on project-oriented workflow. Example # New: Reproducible ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point() ggsave(here(&quot;project&quot;, &quot;outputs&quot;, &quot;example.png&quot;)) How here works here() function shows what’s the top-level project directory. here::here() Build a path including subdirectories here::here(&quot;project&quot;, &quot;outputs&quot;) #depth 1 #depth 2 How here defines the top-level project directory. The following list came from the here package vignette). Is a file named .here present? Is this an RStudio Project? (Note that we already set up an RStudio Project! So, if you use RStudio’s project feature, then you are ready to use here.) Is this an R package? Does it have a DESCRIPTION file? Is this a remake project? Does it have a file named remake.yml? Is this a projectile project? Does it have a file named .projectile? Is this a checkout from a version control system? Does it have a directory named .git or .svn? Currently, only Git and Subversion are supported. If there’s no match then use set_here() to create an empty .here file. Challenge 1 Can you define computational reproducibility? Can you explain why sharing code and data is not enough for computational reproducibility? 2.1.2 Version control (Git and Bash) 2.1.2.1 What Is Bash? 2.1.2.1.1 Writing your first shell script Write a shell script that creates a directory called /pdfs under /Download directory, then find PDF files in /Download and copy those files to pdfs. This shell script creates a backup. #!/bin/sh mkdir /home/jae/Downloads/pdfs cd Download cp *.pdf pdfs/ echo &quot;Copied pdfs&quot; 2.1.2.2 What Are Git and GitHub? Figure 2.1. A schematic git workflow from Healy’s “The Plain Person’s Guide to Plain Text Social Science” 2.1.2.2.1 Basics: git push and git pull 2.1.2.2.2 Time machine: git revert 2.1.2.2.3 Parallel universe: git branch 2.1.2.2.4 User-manual: readme README.md In this simple markdown file, note some basic information about the project including the project structure. This is how I used the README.md file for this course. Check out my GitHub account to see how I manage my projects. 2.1.2.3 Deployment: GitHub Pages 2.1.2.4 Tracking progress: GitHub Issues 2.1.2.5 Project management: GitHub Dashboards 2.2 Writing code: How to code like a professional 2.2.1 Write readable code Files When naming files: Don’t use special characters. Don’t capitalize. Numbering them if files should be run in an order. # Good fit_models.R # Bad fit models.R Objects When naming objects: Don’t use special characters. Don’t capitalize. # Good day_one # Bad DayOne Functions When naming functions: Don’t use special characters. Don’t capitalize. Use verbs instead of nouns. # Good run_rdd # Bad rdd Spacing # Good x[, 1] mean(x, na.rm = TRUE) if (debug) show(x) function(x) {} height &lt;- (feet * 12) + inches sqrt(x^2 + y^2) # Bad x[,1] mean (x, na.rm = TRUE) if(debug) show(x) function(x){} height &lt;- (feet*12) + inches sqrt(x ^ 2 + y ^ 2) Indenting # Good if (y &lt; 0 &amp;&amp; debug) { message(&quot;y is negative&quot;) } # Bad if (y &lt; 0 &amp;&amp; debug) message(&quot;Y is negative&quot;) Long lines # Good do_something_very_complicated( something = &quot;that&quot;, requires = many, arguments = &quot;some of which may be long&quot; ) # Bad do_something_very_complicated(&quot;that&quot;, requires, many, arguments, &quot;some of which may be long&quot; ) Comments Use comments to explain why you make what decisions. Show your code; Do not try to explain your code by comments. Also, try to comment out rather than delete the code that you experiment with. # Comment out # mean(jae$sleep, na.rm = T) Pipes # Good iris %&gt;% group_by(Species) %&gt;% summarize_if(is.numeric, mean) %&gt;% ungroup() %&gt;% gather(measure, value, -Species) %&gt;% arrange(value) # Bad iris %&gt;% group_by(Species) %&gt;% summarize_all(mean) %&gt;% ungroup %&gt;% gather(measure, value, -Species) %&gt;% arrange(value) Additional tips Use lintr to check whether your code complies with a recommended style guideline (e.g., tidyverse) and styler package to format your code according to the style guideline. how lintr works 2.2.2 Write reusable code Pasting Copy-and-paste programming, sometimes referred to as just pasting, is the production of highly repetitive computer programming code, as produced by copy and paste operations. It is primarily a pejorative term; those who use the term are often implying a lack of programming competence. It may also be the result of technology limitations (e.g., an insufficiently expressive development environment) as subroutines or libraries would normally be used instead. However, there are occasions when copy-and-paste programming is considered acceptable or necessary, such as for boilerplate, loop unrolling (when not supported automatically by the compiler), or certain programming idioms, and it is supported by some source code editors in the form of snippets. - Wikipedia Example Let’s imagine df is a survey data. a, b, c, d = Survey respondents -99: non-responses Your goal: replace -99 with NA # Data df &lt;- tibble(&quot;a&quot; = -99, &quot;b&quot; = -99, &quot;c&quot; = -99, &quot;d&quot; = -99) # Copy and paste df$a[df$a == -99] &lt;- NA df$b[df$b == -99] &lt;- NA df$c[df$c == -99] &lt;- NA df$d[df$d == -99] &lt;- NA df ## # A tibble: 1 x 4 ## a b c d ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA NA NA NA Using a function function: input + computation + output If you write a function, you gain efficiency because you don’t need to copy and paste the computation part. # Function fix_missing &lt;- function(x) { x[x == -99] &lt;- NA x } # Apply function to each column (vector) df$a &lt;- fix_missing(df$a) df$b &lt;- fix_missing(df$b) df$c &lt;- fix_missing(df$c) df$d &lt;- fix_missing(df$d) df Automation Many options for automation in R: for loop, apply family, etc. Here’s a tidy solution comes from purrr package. The power and joy of one-liner. df &lt;- purrr::map_df(df, fix_missing) df Takeaway: Your code is more reusable, when it’s easier to change, debug, and scale up. 2.2.3 Test your code systematically 2.3 Asking questions: Minimal reproducible example 2.3.1 How to create a minimal reproducible example References Project-oriented research Computational reproducibility “Good Enough Practices in Scientific Computing” by PLOS Project Management with RStudio by Software Carpentry Initial steps toward reproducible research by Karl Broman Version control Version Control with Git by Software Carpentry The Plain Person’s Guide to Plain Text Social Science by Kieran Healy Writing code Style guides R Google’s R style guide R code style guide by Hadley Wickham The tidyverse style guide by Hadley Wickham Python Google Python Style Guide Code Style by the Hitchhiker’s Guide to Python Asking questions "],
["tidy-data.html", "Chapter 3 Tidy data and its friends 3.1 Tidy data and why it matters 3.2 Wrangling data 3.3 How to wrangle data 3.4 How to wrangle data at scale 3.5 Modeling and visualizing tidy data", " Chapter 3 Tidy data and its friends 3.1 Tidy data and why it matters 3.2 Wrangling data 3.3 How to wrangle data 3.4 How to wrangle data at scale 3.5 Modeling and visualizing tidy data "],
["functional-programming.html", "Chapter 4 Automating repeated things 4.1 From for loop to functional programing 4.2 Developing your own data tools", " Chapter 4 Automating repeated things 4.1 From for loop to functional programing 4.2 Developing your own data tools "],
["semi-structured-data.html", "Chapter 5 Semi-structured data 5.1 HTML/CSS: web scraping 5.2 XML/JSON: social media scraping", " Chapter 5 Semi-structured data 5.1 HTML/CSS: web scraping 5.2 XML/JSON: social media scraping "],
["machine-learning.html", "Chapter 6 High-dimensional data 6.1 Supervised machine learning 6.2 Unsupervised machine learning", " Chapter 6 High-dimensional data 6.1 Supervised machine learning 6.1.1 Regularization 6.1.2 Decision tree and ensemble models 6.2 Unsupervised machine learning 6.2.1 Dimension reduction 6.2.2 Clustering "],
["big-data.html", "Chapter 7 Big data 7.1 Database and SQL", " Chapter 7 Big data 7.1 Database and SQL "]
]
